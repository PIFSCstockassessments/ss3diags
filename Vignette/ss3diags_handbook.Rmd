---
title: "User Guidelines for Advanced Model Diagnostics with ss3diags"
author:
- Hennig Winker (JRC-EC)
- Felipe Carvalho (NOAA)
- Massimiliano Cardinale (SLU)
- Laurence Kell (Sea++)
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: yes
    number_sections: true
  pdf_document:
    number_sections: yes
    toc: yes
    keep_tex: no
vignette: |
  %\VignetteIndexEntry{ss3daigs Vignetted} %\VignetteEngine{knitr::rmarkdown} \usepackage[utf8]{inputenc}
---

```{r wrap-hook, echo = FALSE}
library(knitr)
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
```


```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "  " ,fig.align = 'center', cache=FALSE,tidy.opts=list(width.cutoff=80), tidy=TRUE)

```



# Getting started {#s1}

This vignette introduces you to the `ss3diags` R package, which accompanies the paper “A cookbook for using model diagnostics in integrated stock assessments” by Carvalho, Winker et al. (2021). 

The `ss3diags` comprises a set of functions for applying advanced model diagnostics to Stock Synthesis models. The  package builds on the widely used R package `r4ss` [(Taylor et al. 2021)](https://www.sciencedirect.com/science/article/abs/pii/S0165783621000527), which is designed to support the use of the Stock Synthesis software modeling framework [(Methot and Wetzel, 2013)](https://www.sciencedirect.com/science/article/abs/pii/S0165783612003293).
<br>
This vignette is divided into four sections. [Section 1](#s1) consists of installing `ss3diags` and loading the example data from a simulated, cod-like stock that is included with the package. [Section 2](#s2) describes the plotting of various model diagnostics as described in the [Cookbook](https://www.sciencedirect.com/science/article/pii/S0165783621000874). [Section 3](#s3) provides a detailed explanation on how to assess model uncertainty using `ss3diags`. In [Section 4](#s4) we provide a series of “cookbook recipes” on how to implement selected model diagnostics on Stock Synthesis models.  

## Installation

Both `ss3diags` and `r4ss` can be installed from gihtub using the `remotes ` package:

```{r, eval=FALSE}
install.packages("remotes")

remotes::install_github("r4ss/r4ss")

remotes::install_github("PIFSCstockassessments/ss3diags")
```
Once the packages are installed they can be loaded by:

```{r}
library(r4ss)
library(ss3diags)
```

## Loading built-in example data

The package contains output from a simple, cod-like SS model that was simulated using ss3sim. The model includes 2 fleets, one fishery and one survey. Catch data is available from year 26 to year 100 (final year of model). An index of abundance is available from the survey fleet for years 62 - 100. No discard data was simulated. Simulated composition data includes length (fleets 1 and 2), age (fleets 1 and 2), and conditional age-at-length (fleet 1). Examples of the the output of a single run (as read by `r4ss::SS_output()`) of the model as well as the output from a retrospective analysis with 5 year peels (as read by `r4ss::SSgetout()`) are available with the package.

### "Simple" model
<br>
The example outputs can be loaded into R by: 
```{r}
#Single run output
data("simple")

#retrospective analysis output
data("retroSimple")
```


- `simple`: list of stock synthesis objects created with `r4ss::SS_output()`
- `retroSimple`: list of retrospective runs created with `r4ss:SS_doRetro()` and read by `r4ss::SSgetoutput()`.
  - The first object in the list is the reference run and the other 5 objects are the 5 1-year peels. 
<br>

# Model Diagnostics with ss3diags {#s2} 

<br>

The plotting options are kept mainly to those provided by [r4ss](https://github.com/r4ss/r4ss).
Like with [r4ss](https://github.com/r4ss/r4ss), if, for example, `SSplotRunstest() called with no further specifications several windows will open, the number of windows depends on the number abundance indices.

## Residual diagnostics

The runs test is a nonparametric hypothesis test for randomness in a data sequence that calculates the 2-sided p-value to estimate the number of runs (i.e., sequences of values of the same sign) above and below a reference value. The runs test can diagnose model misspecification using residuals from fits to abundance indices [Carvalho et al. 2017](https://www.sciencedirect.com/science/article/pii/S0165783616303113) by testing if there are non-random patterns in the residuals. It can also be applied to other data components in assessment models such as the mean-length residuals and mean-age residuals. In addition, the three-sigma limits can be considered to identify potential outliers as any data point would be unlikely given a random process error in the observed residual distribution if it is further than three standard deviations away from the expected residual process average of zero.
<br>

The output for `SSplotRunstest()` includes a plot of the residuals by fleet and a table with the results from the runs test and 'three-sigma limit' values. In the plots below, the shaded area  represents the 'three-sigma limit', or three residual standard deviations from zero. If any of the individual residual points fall outside of the three-sigma limit, they are colored red as in the fishery length-composition. Green shaded area indicates the residuals are randomly distributed (p-value >= 0.05) and red shaded area indicates the residuals are not randomly distributed and there is some misspecification with the indices or composition data (p-value < 0.05).
<br>
To visualize the runs test for multiple indices, it is recommended to use the function `r4ss::sspar()` to specify row and column layout and any other plotting parameters. The option `add=TRUE` included in any of the ss3diags plotting functions prevents the functions from over-writing `sspar()`.

<br>

```{r fig1, fig.cap = "Runs test plots for CPUE index fits. Green shading indicates no evidence (p ≥ 0.05) and red shading evidence (p < 0.05) to reject the hypothesis of a randomly distributed time-series of residuals. The shaded (green/red) area spans three residual standard deviations to either side from zero, and the red points outside of the shading violate the ‘three-sigma limit’ for that series."}
r4ss::sspar(mfrow = c(2,2))
SSplotRunstest(simple, subplots = "cpue", add = TRUE)
SSplotRunstest(simple, subplots = "len", add = TRUE)
SSplotRunstest(simple, subplots = "con", add = TRUE)
```

<br>
<br>

It is also possible to select the indices that should be plotted. For example, if we only want to plot the fishery length composition residuals, we can specify this with the `indexselect` argument. 
<br><br>

```{r fig2, fig.cap="Runs test plot for fits to fishery length composition data."}
r4ss::sspar()
SSplotRunstest(simple, subplots = "len", indexselect = 1, add = TRUE)
```

<br>

In addition to the residual plots, `SSplotRunstest()` produces a summary table of the runs test output values, including: 

  * p-value for the runs test  
  * if the test passed or failed (indicated by green or red shading in the plot)
  * upper and lower limits for the 3-sigma interval 
  * type of data tested (CPUE, length-composition, age-composition, or conditional age-at-length)
  
To only produce the summary table and skip the plot, e.g. to faciliate automated processing, use `SSrunstest()`. 

```{r}
rcpue <- SSrunstest(simple, quants = "cpue")
rlen <- SSrunstest(simple, quants = "len")
rbind(rcpue, rlen)
```

<br>
The second function for residual diagnostics is the function `SSplotJABBAres()`. This function is from the R package [JABBA](https://github.com/jabbamodel/JABBA) and plots a time series of residuals for all fleets of the indicated data (CPUE or composition). In the example below, we plot the residuals for the mean age (age-composition) and mean length (length-composition) for both fleets. 

<br>
```{r fig3, message=FALSE, warning=FALSE, fig.cap="Joint residual plots for fits to age and length compositions, where the vertical lines with points show the residuals, and solid black lines show loess smoother through all residuals. Boxplots indicate the median and quantiles in cases where residuals from the multiple indices are available for any given year. Root-mean squared errors (RMSE) are included in the upper right-hand corner of each plot."}
r4ss::sspar(mfrow=c(1,2),plot.cex=0.8)
SSplotJABBAres(simple, subplots = "age", add = TRUE)
SSplotJABBAres(simple, subplots = "len", add = TRUE)
```

<br>
<br>

## Retrospective and Forecast bias 

Retrospective analysis is commonly used to check the consistency of model estimates, i.e., the invariance in spawning stock biomass (SSB) and fishing mortality (F) as the model is updated with new data in retrospect. The retrospective analysis involves sequentially removing observations from the terminal year (i.e., peels), fitting the model to the truncated series, and then comparing the relative difference between model estimates from the full-time series with the truncated time-series.

In Stock Synthesis, retrospective analysis can be routinely implemented using `r4ss:SS_doRetro()` (see [Section 3.1](#r1)). `ss3diags` provides the function `SSplotRetro()` to visualize the retrospective patterns of SBB and F and compute the associated Mohn's rho value (i.e. retrospective bias). This first requires loading the retrospective runs ([Section 1.2]()), which are already built into `ss3diags` in this case. The next step is to summarize the list of retrospective runs using `r4ss::SSsummarize()`.


```{r}
retroI.simple <- r4ss::SSsummarize(retroSimple,verbose=F)
```

We use notation "retroI" because `r4ss::SSsummarize()` summarizes the modeled quantities and abundance indices, but not length or age composition data. Using `retroI.simple` it is possible to produce some basic retrospective plots.

```{r fig4, fig.height=3,fig.cap= "Retrospective analysis of spawning stock biomass (SSB) and fishing mortality estimates for cod-like stock conducted by re-fitting the reference model (Ref) after five years, one year at a time sequentially. Mohn’s rho statistic are denoted on top of the panels. Grey shaded areas are the 95 \\% confidence intervals from the reference model in cases where the analysis was run with Hessian"}

r4ss::sspar(mfrow=c(1,2),plot.cex=0.8)
rssb <- SSplotRetro(retroI.simple, add=TRUE, subplots = "SSB", forecast = F, legend = F, verbose=F)
rf <- SSplotRetro(retroI.simple, add=TRUE, subplots="F", ylim=c(0.05,0.2),
            forecast=F, legendloc="topright", legendcex = 0.8, verbose=F)

```
 <br>
 
An intuitive extension of the retrospective analysis is to assess potential forecast bias by adding the additional step of forward projecting quantities, such as SSB, over the truncated years. In Stock Synthesis the forecasts are automatically done when using `r4ss:SS_doRetro()`.The forecasts are based on the settings specified in ‘forecast.ss’, which are also evoked when conducting future projections with the same model. The observed catches are used for the retrospective forecasts. Retrospective forecasts with Stock Synthesis are therefore only a matter of visualization, which can be done by setting the `SSplotRetro()` option `forecast=TRUE`.


```{r fig5, fig.height=3.,fig.cap= "Retrospective results shown for the most recent years only. Mohn’s rho statistic and the corresponding ‘hindcast rho’ values (in brackets) are now printed at the top of the panels. One-year-ahead projections denoted by color-coded dashed lines with terminal points are shown for each model."}

r4ss::sspar(mfrow=c(1,2),plot.cex=0.8)
rssb <- SSplotRetro(retroI.simple, add = T, subplots = "SSB", forecast = T, 
                    legend = F, verbose = F, xmin = 2000, ylim = c(0.5E9, 2.5e9))
rf <- SSplotRetro(retroI.simple, add = T, subplots = "F", ylim = c(0.05,0.25),
                forecast = T, legendloc = "topleft", legendcex = 0.8, verbose = F, xmin = 2000)

```


\newpage

The statistics from the retrospective analysis with forecasting, Mohn's rho and forecast bias, can be called without plotting using the function `SShcbias()`   

<br><br>  

```{r}
SShcbias(retroI.simple,quant="SSB",verbose=F)

SShcbias(retroI.simple,quant="F",verbose=F)

```

<br> <br> 


## Hindcast Cross-Validation and prediction skill 

Implementing the Hindcast Cross-Validation (HCxval) diagnostic in Stock Synthesis  requires the same model outputs generated by `r4ss:SS_doRetro()` as described in Section [3.1](#r1). Therefore, no additional step is needed for HCxval if conducted in conjunction with retrospective analysis. 
<br> 
As a robust measure of prediction skill, we implemented the mean absolute
scaled error (MASE). In brief, the MASE score scales
the mean absolute error (MAE) of forecasts (i.e., prediction residuals) to
MAE of a naïve in-sample prediction, which is realized in the form of a simple 'persistence algorithm', i.e. tomorrow’s weather will be the same as today’s (see Eq. 3, p.5 in [Carvalho and Winker et al. 2021](https://www.sciencedirect.com/science/article/pii/S0165783621000874)). A MASE score > 1 indicates that the average model forecasts are worse than a random walk. Conversely, a MASE score of 0.5 indicates that the model forecasts twice as accurately as a naïve baseline prediction; thus, the model has prediction skill.

<br> 
HCxval is implemented using function `SSplotHCxval()`, which produces the novel HCxval diagnostic plot and computes the MASE scores for CPUE indices, mean lengths or mean ages that have observations falling within the hindcast evaluation period.
<br> 

Plotting HCxval for abundance indices requires the same step of summarizing the list of retrospective runs as for the retrospective analysis, which therefore only needs be done once. 

```{r fig6, fig.cap= "Hindcasting cross-validation (HCxval) results from CPUE fit, showing observed (large points connected with dashed line), fitted (solid lines) and one-year ahead forecast values (small terminal points). HCxval was performed using one reference model (Ref) and five hindcast model runs (solid lines) relative to the expected CPUE. The observations used for cross validation are highlighted as color-coded solid circles with associated 95 \\% confidence intervals. The model reference year refers to the endpoints of each one-year-ahead forecast and the corresponding observation (i.e., year of peel + 1). The mean absolute scaled error (MASE) score for the survey index is shown at the top of the plot."}

hci <- SSplotHCxval(retroI.simple, add=T, verbose=F, legendcex = 0.7)
```

\newpage
<br>
The forecast length- and age-composition are located in the Stock Synthesis report.sso as "ghost files". To extract and summarize the composition data in the form of observed and expected mean lengths and age `ss3diags` provides the function `SSretroComps()`.

```{r}
retroC.simple <- SSretroComps(retroSimple)
```

```{r fig7, fig.cap= "Hindcasting cross-validation (HCxval) results for mean lengths. Note that MASE values in breakets are adjusted MASE values for cases where naive predictions have a Mean-Absolute-Error below 0.1"}

r4ss::sspar(mfrow=c(1,2),plot.cex=0.8)
hcl <- SSplotHCxval(retroC.simple, subplots="len", add=T, verbose=F, legendcex = 0.7, ylim = c(50, 100))
```
<br>
The figure above  provides some additional, so called adjusted MASE values, in parentheses. This gets invoked in cases where the inter-annual variation in the observed values is very small (default MAE < 0.1 for naive predictions log(y[t+1])-log(y[t])).
The reasoning is that prediction residuals must be already very accurate to fall below this threshold. The adjusted MASE essential keep the naive prediction MAE denominator of the MASE to a maximum. Below we show the effect of changing adjustment threshold from the default `MAE.base.adj = 0.1`


```{r , linewidth=60}
mase1 = SSmase(retroC.simple, quant="len", MAE.base.adj = 0.1)
mase1
```

to a larger value `MAE.base.adj = 0.15`

```{r, linewidth=60}
SSmase(retroC.simple, quant="len", MAE.base.adj = 0.15)
```

where `MASE` is the ratio of the mean absolute error of the prediction residuals `MAE.PR` to the residuals of the naive predictions `MAE.base`

```{r}
mase1$MAE.PR/mase1$MAE.base
mase1$MASE
```

and MASE.adj


```{r}
mase1$MAE.PR/pmax(mase1$MAE.base,0.1)
mase1$MASE.adj
```

Note that applying HCxval for composition data requires correctly specifying the composition data type fitted in the model. For example, age composition data need to be specified as "age" in `SSplotHCxval` and `SSmase`, as shown below.

```{r fig8, fig.cap= "Hindcasting cross-validation (HCxval) results for mean ages. Note that MASE values in brackets are adjusted MASE values for cases where naive predictions have a Mean-Absolute-Error below 0.1"}

hcl <- SSplotHCxval(retroC.simple, subplots="age", add=TRUE,
verbose=F, legendcex = 0.7)

SSmase(retroC.simple,quants="age")
```


\newpage

# Model uncertainty {#s3}

The management advice frameworks increasingly require translating the estimated uncertainty about the stock status into probabilistic statements (Kell et al. 2016). A classic example is the Kobe framework used in tuna Regional Fisheries Management Organisations (tRFMOs) around the world. The key quantities of interest are typically the ratios $SSB/SSB_{MSY}$ and $F/F_{MSY}$. While it is reasonably straight forward in Stock Synthesis to approximate uncertainty of individual quantities (e.g. $SSB$) from the asymptotic standard errors (SE) derived from the Hessian matrix using the delta method, the joint distribution of $SSB/SSB_{MSY}$ and $F/F_{MSY}$ requires adequately accounting for the covariance structure between these two derived quantities. Joint distributions are typically constructed using bootstrap or Markov Chain Monte-Carlo (MCMC) methods. However, these methods can be computationally intense and time-consuming in integrated assessments.  

As an alternative, `ss3diags` implements a rapid delta-Multivariate lognormal approximation with `SSdeltaMVLN()` to generate joint error distributions for $SSB/SSB_{ref}$ and $F/F_{ref}$, where the $ref$ may refer to $MSY$, but also other reference points (e.g., $SSB_{40}$ and $F_{40}$). In Stock Synthesis, these ratios are determined by the derived quantities  `Bratio` and `F`, where either can take the form of ratios (e.g. $F/F_{ref}$) or absolute value (e.g. `absF`) depending on settings in the `starter.ss` file.

Let `Bratio` be $u = SSB/SSB_{ref}$, `F` be $v = F$, and $w = F_{ref}$ be the F reference point of interest (e.g. $F_{MSY}$), with $x = \log(u)$, $y = \log(v)$ and $z = \log(w)$, then the variance-covariance matrix $VCM$ has the form:

$$
VCM_{x,y,z} =
 \begin{pmatrix}
  \sigma^2_{x} & cov_{x,y} & cov_{x,y} \\
  cov_{x,y} & \sigma^2_{y} & cov_{y,z} \\
  cov_{x,z} & cov_{y,z} & \sigma^2_{z}
 \end{pmatrix}
$$

where, e.g., $\sigma^2_{x}$ is the variance of $x$ and $cov_{x,y}$ is the covariance of $x$ and $y$. Deriving those requires conducting a few normal to lognormal transformations. First, the variances are approximated as:

$$
\sigma^2_{x} = \log\left(1+\left(\frac{SE_u}{u}\right)^2\right)  
$$

where $SE_{u}$, $SE_{v}$ and $SE_{z}$ are the asymptotic standard error estimates for $u = SSB/SSB_{ref}$, $v = F$ and $z = F_{ref}$. 

The corresponding covariance for $x$ and $y$, can then be approximated on the log-scale by:

$$
COV_{x,y} = \log \left( {1+\rho_{u,v} \sqrt{\sigma^2_{x}\sigma^2_{y}}} \right) 
$$

where $rho_{u,v}$ denotes the correlation of $u$ and $v$.

To generate a joint distribution of $\tilde{u}$ = $SSB/SSB_{ref}$, $\tilde{v}$ = $F$ and $\tilde{z}$ = $F_{ref}$, a multivariate random generator is used, which is available in the R package ‘mvtnorm’, to obtain a large number (e.g. nsim = 10,000) iterations, such that

$$
JD(\tilde{u},\tilde{v},\tilde{w}) = \exp(MVN(\mu_{x,y,z},VCM_{x,y,z}))
$$
so that

$$ 
\tilde{SSB}/\tilde{SSB}_{{MSY}} = \tilde{u}  
$$ 
and

$$ 
\tilde{F}/\tilde{F}_{{MSY}} = \tilde{v}/\tilde{w}  
$$ 
<br> 
 

The reference points depend on the settings in the `starter.ss` file that determine the derived quantities `Bratio` and `Fvalue`. 

We provide the function `SSsettingsBratioF(ss3sma)` to the `starter.ss` settings:

```{r}
SSsettingsBratioF(simple)
```
This function is also inbuilt in `SSdeltaMVLN()` to prevent misleading results. The `SSdeltaMVLN()` output includes the maximum likelihood estimates (MLEs) and the MVLN Monte-Carlo distributions `$kb` of $SSB/SSB_{MSY}$, $F/F_{MSY}$ and $F$. Note the additional quantities $SSB$ and $Rec$ are generated independently from lognormal distributions for practical reasons. These can be plotted by

The `SSdeltaMVLN()` provides the option to set alternative `Fref` values, but this is only possible for the recommended `starter.ss` option 0 for `F_report_basis`. For option 2, `SSdeltaMVLN()` prompts an error if `Fref` is changed.

The `simple` model is run with settings that are common in NOAA assessments, with `Bratio` set to $SSB/SSB_{0}$ and `F` is typically kept at absolute quantity.   

`1 # Depletion basis: 1=rel X*SB0; 2=rel SPBmsy; 3=rel X*SPB_styr; 4=rel X*SPB_endyr`

`0 # F_report_basis: 0=raw_F_report; 1=F/Fspr; 2=F/Fmsy ; 3=F/Fbtgt`

The management quantities in this case are $SSB/SSB_{40}$ and $F/F_{spr40}$, where the target of 40\% is specified in the `forecast.ss` file.

`0.4 # SPR target (e.g. 0.40)`  

`0.4 # Biomass target (e.g. 0.40)`

```{r fig9, fig.cap="Kobe phase plots showing MVLN Kobe probability distributions of $SSB/SSB_{40}$ and $F/F_{SPR40}$ for the simple SS3 model."}

mvln <- SSdeltaMVLN(simple, run="Simple", Fref="SPR", plot=TRUE) 

```


```{r fig10, fig.cap="Distributions for $SSB/SSB_{40}$, $F/F_{SPR40}$, $SSB$, $F$, Recruitment and Catch trajectories for the simple SS3 model", warning=FALSE, message=FALSE} 
r4ss::sspar(mfrow=c(3,2),plot.cex = 0.7)
SSplotEnsemble(mvln$kb, ylabs=mvln$labels, add=T, verbose=F) 
```

<br> 

It is important to note that MVLN approximation differs notably from MCMC posterior for this model as documented in [Stewart et al. (2013)](https://www.sciencedirect.com/science/article/abs/pii/S0165783612002081) and [Taylor et al. (2021)](https://www.sciencedirect.com/science/article/abs/pii/S0165783621000527). Such differences may be more likely to occur in cases where key parameters such as steepness $h$ or natural $M$ are estimated using informative priors, which can result in left skewed (non-lognormal) distributions of the benchmarks $F_{ref}$ and $B_{ref}$. 

In other instances, mismatches between the`SSdeltaMVLN` and MCMC may also be caused by the latter's poor performance  due to poor regularization [(Monnahan et al., 2019)](https://academic.oup.com/icesjms/article/76/6/1477/5475859?login=true).

To facilitate a comparison between the `SSdeltaMLVN()` and MCMC outputs, we provide the function `SSdiagsMCMC()`, which is illustrated on the example of the Stock Synthesis model for the ICES Gulf of Bothian Herring stock [(ICES, 2021)](https://www.ices.dk/sites/pub/Publication%20Reports/Stock%20Annexes/2021/her.27.3031_SA.pdf). 


`SSdiagsMCMC()` requires loading both the `report.sso` and MCMC output in the `posterior.sso` file, where the MCMC was in this case run in the subfolder of the assessment file `/mcmc`. 

```{r }
# MCMC example included in ss3diags
data("mcmcSimple")
```

The options and output of `SSdiagsMCMC()` are largely identical to `SSdeltaMVLN`. 

```{r, linewidth=60}
mvln <- SSdeltaMVLN(simple, plot=F, run="mvln")
mcmc <- SSdiagsMCMC(mcmcSimple, simple, plot=F, run="mcmc")
mcmc$kb <- dplyr::filter(mcmc$kb, year > 27)
```
<br>
Comparing delta-MVLN with MCMC simply requires combining the `$kb` outputs by, e.g.,


```{r fig11, warning=FALSE, fig.cap="Kobe phase plot comparing MVLN and MCMC posterior distributions of $SSB/SSB_{40}$ and $F/F_{40}$  for the simple SS3 model"} 
r4ss::sspar(mfrow=c(1,1),plot.cex = 0.8)
SSplotKobe(rbind(mvln$kb, mcmc$kb), joint=F,
   xlab=mvln$labels[1], ylab=mvln$labels[2], fill=F)


```



```{r fig12, warning=FALSE, fig.cap="Comparison of MVLN and MCMC posterior distributions for $SSB/SSB_{40}$, $F/F_{SB40}$, $SSB$ and $F$ for the simple SS3 model"} 

r4ss::sspar(mfrow=c(2,2),plot.cex = 0.7)
SSplotEnsemble(rbind(mvln$kb,mcmc$kb),ylabs=mvln$labels,add=T,subplots = c("stock", "harvest", "SSB", "F"),verbose=F)

```


<br>
This works equally for joining a model ensemble. 

\newpage
